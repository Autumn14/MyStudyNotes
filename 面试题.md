# 面试题

## 1.`var`和`let`的区别：

变量提升：`var`存在变量提升，而`let`不存在。
作用域：`var`作用域是函数级别，而`let`是块级，即一对花括号包裹的代码区域。
重复声明：`var`允许重复声明，后面的会覆盖前面的，而`let`不允许。

## 2.== 和 equals 的区别是什么？

“==” 是比较运算符。
对于基本数据类型，比较的是值。
对于引用数据类型，比较的是内存地址。

equals 方法在 Object 类中与 “==” 作用相同。
但很多类重写了 equals 方法，用于比较对象的内容是否相等，如 String 类。

## 3.String、StringBuffer 和 StringBuilder 的区别是什么？

String 是不可变字符串，每次修改都会创建新的 String 对象。
StringBuffer 是可变字符串，线程安全，方法都用 synchronized 修饰，性能相对低。
StringBuilder 也是可变字符串，非线程安全，性能高。

## 4.说一下 JVM 的主要组成部分及其作用？

JVM 主要由类加载器、运行时数据区、执行引擎和本地库接口组成。
类加载器负责加载类文件到内存。
运行时数据区包括堆、栈、方法区等，用于存储程序运行时的各种数据。
执行引擎负责执行字节码指令。
本地库接口用于融合不同语言为 Java 所用。

## 5.简述 Java 垃圾回收机制

Java 垃圾回收机制是一种自动内存管理机制，用于释放不再被使用的对象占用的内存。
JVM 通过可达性分析算法判断对象是否可被回收。
垃圾回收器会在合适的时机对堆内存中的新生代和老年代进行垃圾回收。
采用标记-清除、复制、标记-整理、分代收集等算法。

## 6.什么是 Spring IOC 容器？

Spring IOC 容器是 Spring 框架的核心，负责创建、管理和装配 Bean 对象。
它通过控制反转（IoC）的思想，将对象的创建和依赖关系的管理从应用程序代码中分离出来，由容器来负责，提高了代码的可维护性和可扩展性。

## 7.@Autowired 和 @Resource 之间的区别？

@Autowired 是 Spring 框架的注解，默认按类型装配，可通过 @Qualifier 注解指定按名称装配。
@Resource 是 JDK 的注解，默认按名称装配，找不到名称匹配时按类型装配。

## 8.什么是线程死锁？如何避免线程死锁？

线程死锁是指两个或多个线程相互等待对方释放资源，导致所有线程都无法继续执行的情况。
避免方法有：
避免一个线程同时获取多个锁；
按顺序获取锁；
使用定时锁，设置获取锁的超时时间；
使用 ReentrantLock 等可重入锁的 tryLock 方法尝试获取锁。

## 9.在 Java 程序中怎么保证多线程的运行安全？

可以使用 synchronized 关键字修饰方法或代码块实现同步；
使用 ReentrantLock 等显式锁；
使用原子类，如 AtomicInteger 等保证原子操作；
使用线程安全的集合类，如 ConcurrentHashMap 等；
使用线程池管理线程，避免线程的频繁创建和销毁等。

## 10.MySQL 中有哪几种锁？

从锁的粒度分，有表锁、行锁和页锁。
从锁的性质分，有共享锁（读锁）和排他锁（写锁）。
另外还有意向锁、间隙锁等。

## 11.数据库三大范式是什么？

第一范式（1NF）：原子性，表中的每个属性（数据表的列）不能再分。
第二范式（2NF）：在满足 1NF 的基础上，非主属性必须依赖于整个主键或候选键，不能只依赖于主键或候选键的一部分属性。（唯一性）
第三范式（3NF）：在满足 2NF 的基础上，任何非主属性不能依赖于其他非主属性。（独立性）

>属性（attribute）： 数据库中的字段，即数据库中表的列。
>超键（super key）： 在关系中能唯⼀标识元组的属性集称为关系模式的超键
>候选键（candidate key）： 不含有多余属性的超键称为候选键
>主键（primary key）： ⽤户选作元组标识的⼀个候选键称为主键
>外键（foreign key）： 在一个表中存在的另一个表的主键称为此表的外键。
>主属性： 候选键中的属性称为主属性。
>非主属性： 不属于任何候选键的属性称为非主属性。

>属性： 把数据库中的一个表类比成一个公司，那么公司里的每个人都是一个“属性”（表中的一个字段视为一个属性），不管老板还是员工，只要是公司里的人，就都是一个属性。
>
>超键： 有候选人（包括老板）的一堆人就是“超键”（能唯⼀标识元组的属性集）。当然这堆人也可以只包含候选人或老板，这样也叫“超键”。
>
>候选键： 公司不是独裁制的，老板这个位置有很多候选人，他们都有能力指挥所有普通员工（候选键都可以唯一标识属性元组），这些候选人就是“候选键”，但是所有候选人里只能选出一个做老板（主键是一个被选中的候选键），老板是特殊的候选人。当然，候选人可能也其实是几个人的组合，比如另外几个兄弟的组合，但他们也得一起行动才有能力指挥员工（候选键中所有属性的组合才能唯一地标识属性元组）。
>
>主键： 老板就是“主键”，所有普通员工都得听他的（主键可以唯一地标识属性元组）。但是，老板未必是一个人，可能在法律上我和我兄弟同时是公司的老板（主键可能是多个属性的组合）。要指挥员工，需要我们俩一起指挥才行（主键中所有属性的组合才能唯一地标识属性元组）。
>
>外键： 公司里某个人（或某几个人的组合）是另一个公司的老板，那他或他们就是“外键”（一个表中存在的另一个表的主键称为此表的外键）。
>
>主属性： 是候选人或老板的人（或是候选人组合中的一个）就是“主属性”（候选键中的属性称为主属性）。
>
>非主属性： 不是候选人或老板的人（也不在任何候选人组合中）就是“非主属性”（不属于任何候选码的属性称为非主属性）。

## 12.MySQL的事物隔离级别都有哪些?

- **读未提交（Read Uncommitted）**：允许事务读取其他事务未提交的数据，可能会出现脏读、不可重复读和幻读问题。
- **读已提交（Read Committed）**：只能读取其他事务已提交的数据，可避免脏读，但仍可能出现不可重复读和幻读。
- **可重复读（Repeatable Read）**：在一个事务内多次读取同一数据时，读取的结果是一致的，可避免脏读和不可重复读，但可能出现幻读，是 MySQL 的默认事务隔离级别。
- **串行化（Serializable）**：所有事务依次串行执行，可避免所有并发问题，但性能较低。

## 13.Java8新特性

Java 8 引入了**流（Stream）**的概念，它是一种对集合进行操作的高级工具，可以让你以声明式的方式处理数据集合，类似于 SQL 对数据库进行操作。

流操作可以是中间操作（Intermediate Operations）或终端操作（Terminal Operations）。

- 中间操作会返回一个新的流，可以对元素进行转换、过滤等操作，它们是惰性求值的，不会立即执行，只有在遇到终端操作时才会触发。

- 常见的中间操作有 `filter`、`map`、`sorted`、`distinct` 等。

  - `filter` 操作根据给定的条件过滤流中的元素。它接收一个 `Predicate`（断言）作为参数，这个 `Predicate` 是一个函数式接口，用于测试元素是否满足特定条件。如果元素满足条件，则该元素会被保留在结果流中；如果不满足，则会被过滤掉。

    收起。

  - `map` 操作将流中的元素映射为另一种元素。它接收一个 `Function`（函数）作为参数，这个 `Function` 是一个函数式接口，用于将输入元素转换为另一个元素。

  - `sorted` 操作对流中的元素进行排序。如果不提供自定义的 `Comparator`，则使用元素的自然顺序进行排序（元素需要实现 `Comparable` 接口）。也可以提供一个 `Comparator` 来指定排序规则。

  - `distinct` 操作会去除流中重复的元素。它使用元素的 `equals` 方法来判断元素是否重复。

    **总结**：

    - `filter`：根据条件过滤元素。
    - `map`：将元素映射为另一种元素。
    - `sorted`：对元素进行排序，可以使用自然顺序或自定义的 `Comparator`。
    - `distinct`：去除流中的重复元素。

- 终端操作会产生一个结果或副作用，它会触发流的处理流程。

- 常见的终端操作有 `forEach`、`collect`、`reduce`、`count` 等。

  - `forEach` 操作是一个终端操作，用于遍历流中的元素，并对每个元素执行一个操作。它接收一个 `Consumer` 作为参数，这个 `Consumer` 是一个函数式接口，用于对元素进行操作（如打印、修改外部状态等）。

  - `collect` 操作是一个非常强大的终端操作，用于将流中的元素收集到一个集合或其他数据结构中。它通常与 `Collectors` 类的静态方法一起使用，例如 `toList()`、`toSet()`、`toMap()` 等。

  - `reduce` 操作将流中的元素进行归约（即组合），最终得到一个结果。它接收一个 `BinaryOperator` 作为参数，这个 `BinaryOperator` 是一个函数式接口，用于将两个元素组合成一个元素。

  - `count` 操作是一个终端操作，用于计算流中元素的数量。

    收起

    **总结**：

    - `forEach`：遍历流中的元素并对每个元素执行操作。
    - `collect`：将流中的元素收集到集合或其他数据结构中。
    - `reduce`：将流中的元素进行归约，得到一个结果，可以提供或不提供初始值。
    - `count`：计算流中元素的数量。

**Java 拉姆达表达式（Lambda Expression）**

Lambda 表达式是 Java 8 中引入的一个重要特性，它允许将函数作为方法参数，实现了函数式编程的部分功能。

`(parameters) -> expression` 或 `(parameters) -> { statements; }`

- Lambda 表达式通常和函数式接口一起使用。函数式接口是只有一个抽象方法的接口。

- Lambda 表达式可以捕获外部的变量，但需要注意变量的可变性。

- 方法引用是 Lambda 表达式的一种简化形式，使用 `::` 操作符。

- 将 Lambda 表达式和流结合使用可以让代码更加简洁和强大。
