# JavaScript学习

## 1.基础

**介绍**

JavaScript 是**区分大小写**的，并使用 **Unicode** 字符集。

在 JavaScript 中，指令被称为**语句**，并用分号（;）进行分隔。

如果一条语句独占一行的话，那么分号是可以省略的。但如果一行中有多条语句，那么这些语句*必须*用分号进行分隔。

**注释**

单行：`//`

多行：`/* */`

**声明**

`var` 声明一个变量，可选择将其初始化为一个值。

`let` 声明一个块级作用域的局部变量，可选择将其初始化为一个值。

`const` 声明一个块级作用域的只读命名常量。

**变量**

变量的名字又叫**标识符**，命名规则如下：

JavaScript 标识符通常以字母、下划线（`_`）或者美元符号（`$`）开头；后续的字符也可以是数字（`0`-`9`）。

**初始化**

声明变量的时候，可以顺便进行变量初始化。

如果声明变量的时候没有进行变量初始化，变量会被赋值为`undefined`。

**作用域**

- 全局作用域：在脚本运行的所有代码的默认作用域。
- 模块作用域：在模块模式中运行代码的代码作用域。
- 函数作用域：由函数创建的作用域。
- 块级作用域：用一对花括号创建的作用域。

`var` 声明的变量会被提升，可以在该变量所在的作用域的任意地方引用，即使是还没有到达该变量声明的地方。

由于存在变量提升，所以`var`语句尽量放在接近函数顶部的地方。

**全局变量**

全局变量是全局对象的属性。

在网页中，全局对象是`window`。

`window`对象表示一个包含DOM文档的窗口，其`document`属性指向窗口中载入的DOM文档。

在所有环境中，`globalThis`全局变量。

**常量**

`const`声明一个只读常量。

常量不可以通过赋值来改变其值，也不可以在脚本运行时被重新声明。必须为其初始化一个值。

不过，`const`仅阻止重新赋值，而不阻止修改。

常量对象的属性是不受保护的。

数组也是不受保护的。

**数据结构和类型**

七种基本数据类型：

- Boolean `true`或`false`
- null 一个表示空值的特殊关键字。
- undefined 一个表示未定义值的属性。
- Number 数字，整数或浮点数。
- BigInt 任意精度的整数。
- String 文本，字符串。
- Symbol 符号，实例是唯一且不可变的。

第八种数据类型是：Object

**数据类型的转换**

 JavaScript 是动态类型的。

自动拆装箱。

**运算符**

在使用`+`运算符时，如果表达式中涉及数字和字符串，JavaScript 会把数字转换成字符串。在使用其它运算符的时候不会。

**字符串转数字**

- `parseInt()`
- `parseFloat()`

**字面量**

表示固定值的一种表示法。

- 数组字面量：`[]`
- 布尔字面量：`true`或`false`
- 数字字面量：整数、浮点数或科学计数法
- 对象字面量：`{}`
  - 如果对象的属性名字不合法，那么便不能用点（`.`）来访问属性值。而是通过方括号表示法（`[]`）来访问。

- RegExp字面量：正则表达式字面量，是字符被正斜杠围成的表达式。
- 字符串字面量：由一对双引号（`"`）或单引号（`'`）括起来的零个或多个字符
- 模板字面量：模板字面量由一对反引号（`）包围。
  - **带标签的模板字面量就是函数调用的语法糖**

**在字符串中使用特殊字符**

| 字符        | 意思                                                         |
| :---------- | :----------------------------------------------------------- |
| `\0`        | 空字节                                                       |
| `\b`        | 退格符                                                       |
| `\f`        | 换页符                                                       |
| `\n`        | 换行符                                                       |
| `\r`        | 回车符                                                       |
| `\t`        | 制表符                                                       |
| `\v`        | 垂直制表符                                                   |
| `\'`        | 撇号或单引号                                                 |
| `\"`        | 双引号                                                       |
| `\\`        | 反斜杠字符                                                   |
| `\XXX`      | 由从 `0` 到 `377` 最多三位八进制数 `XXX` 表示的 Latin-1 字符。例如，`\251` 是版权符号的八进制序列。 |
| `\xXX`      | 由从 `00` 和 `FF` 的两位十六进制数字 `XX` 表示的 Latin-1 字符。例如，`\xA9` 是版权符号的十六进制序列。 |
| `\uXXXX`    | 由四位十六进制数字 `XXXX` 表示的 Unicode 字符。例如，`\u00A9` 是版权符号的 Unicode 序列。 |
| `\u{XXXXX}` | Unicode 码位转义。例如，`\u{2F804}` 相当于 Unicode 转义 `\uD87E\uDC04`。 |

**转义字符**

通过在引号前加上反斜杠，可以在字符串中插入引号，这就是*引号转义*。

## 2.控制流和错误处理

**块语句**

块由一对花括号界定

块语句通常用于控制流语句（`if`、`for`、`while`）

**条件语句**

JavaScript 支持两种条件语句：`if...else` 和 `switch`。

假值，下面这些值求值为 `false`

- `false`
- `undefined`
- `null`
- `0`
- `NaN`
- 空字符串（`""`）

所有其他的值，包括所有的对象，在被传递给条件语句时会求值为 `true`。

switch语句：

```javascript
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

case到，如果执行语句是break，则会跳出，如果没有break，继续执行。

如果没有case到，程序会去找default，然后执行语句。

default不是必须的。

**异常处理语句**

用 `throw` 语句抛出一个异常并且用 `try...catch` 语句处理它。

可以抛出任意表达式而不是特定类型的表达式。

异常类型：

- ECMAScript异常
- DOMException

可以使用 `catch` 块来处理所有可能在 `try` 块中产生的异常。

```javascript
catch (exception) {
  statements
}
```

`finally` 块包含的语句在 `try` 和 `catch` 块执行 *之后* 执行。

`finally` 块在 `try…catch…finally` 语句后面的代码 *之前* 执行。

注意，`finally` 块*无论是否*抛出异常都会执行。

如果抛出了一个异常，就算没有 `catch` 块处理抛出的异常，`finally` 块里的语句也会执行。

**嵌套 try...catch 语句**

内部 `try` 块可以*没有*对应的 `catch` 块，但不能没有`finally` 块。

**使用 Error 对象**

根据错误类型，你也许可以用 `name` 和 `message` 属性获取更精炼的信息。

## 3.循环与迭代

循环提供了一种快速和简单的方式去做一些重复的事。

**`for` 语句**

一个 `for`循环会一直重复执行，直到指定的循环条件为 false。

```js
for ([initialExpression]; [condition]; [incrementExpression])
  statement
```

- initialExpression 初始表达式
- condition 判断表达式
- incrementExpression 更新表达式

**`do...while` 语句**

`do...while` 语句一直重复直到指定的条件求值得到假值（false）

```js
do
  statement
while (condition);
```

**`while` 语句**

一个 `while` 语句只要指定的条件求值为真（true）就会一直执行它的语句块。

```js
while (condition)
  statement
```

**`label` 语句**

一个 `label`提供了一个让你在程序中其他位置引用它的标识符。

```js
label :
   statement
```

`label` 的值可以是任何的非保留字的 JavaScript 标识符， `statement` 可以是任意你想要标识的语句（块）。

循环嵌套

添加了label后，break跳出，是跳出整个循环。

不加label，break跳出，是跳出当前循环。

**`continue` 语句**

`continue` 语句可以用来继续执行（跳过代码块的剩余部分并进入下一循环）

循环嵌套

添加了label后，continue继续，是从整个label标签循环继续。

不加label，continue继续，是从当前循环继续。

**`for...in` 语句**

`for...in` 语句循环一个指定的变量来循环一个对象所有可枚举的属性。JavaScript 会为每一个不同的属性执行指定的语句。

```js
for (variable in object) {
  statements
}
```

**`for...of` 语句**

`for...of`语句在可迭代对象（包括`Array`、`Map`、`Set`、`arguments`等等）上创建了一个循环，对值的每一个独特属性调用一次迭代。

```js
for (variable of object) {
  statement
}
```

`for...in` 循环遍历的结果是数组元素的下标，而 `for...of` 遍历的结果是元素的值。

## 4.函数

### 定义函数

一个**函数定义**（也称为**函数声明**，或**函数语句**）由 `function`关键字，并跟随以下部分组成：

- 函数名称。
- 函数参数列表，包围在括号中并由逗号分隔。
- 定义函数的 JavaScript 语句，用大括号括起来，`{ /* … */ }`。

参数本质上是**按值**传递给函数的——因此，即使函数体的代码为传递给函数的参数赋了新值，**这个改变也不会反映到全局或调用该函数的代码中**。

如果你将对象作为参数传递，而函数改变了这个对象的属性，这样的改变对函数外部是可见的。

如果你将数组作为参数传递，而函数改变了这个数组的值，这样的改变对函数外部也同样可见。

**函数表达式**

虽然上面的函数声明在语法上是一个语句，但函数也可以由函数表达式创建。

这样的函数可以是**匿名**的；它不必有一个名称。

然而，*也可以*为函数表达式提供名称，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数。

当将**函数作为参数**传递给另一个函数时，函数表达式很方便。

当一个函数是一个对象的属性时，称之为**方法**。

### 调用函数

*定义*的函数并不会自动*执行*它。定义了函数仅仅是赋予函数以名称并明确函数被调用时该做些什么。

**调用**函数才会以给定的参数真正执行这些动作。

函数一定要处于调用它们的*作用域中*，但是函数的声明可以被提升（出现在调用语句之后）。

函数声明的范围是声明它的函数（或者，如果它是在顶层声明的，则为整个程序）之内。

函数的参数并不局限于字符串或数字。你也可以将整个对象传递给函数。

函数可以调用其本身。**递归**

递归的经典案例：阶乘。

**函数提升**

 JavaScript 解释器会将整个函数声明提升到当前作用域的顶部。

函数提升仅适用于函数*声明*，而不适用于函数*表达式*。

### 函数作用域

在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的作用域内定义。相对应的，一个函数可以访问定义在其范围内的任何变量和函数。

换言之，定义在全局域中的函数可以访问所有定义在全局域中的变量。在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量。

### 作用域和函数栈

**递归**

一个函数可以指向并调用自身。有三种方法可以达到这个目的：

- 函数名

- `arguments.callee`
- 作用域内一个指向该函数的变量名

调用自身的函数我们称之为*递归函数*。

在某种意义上说，递归近似于循环。两者都重复执行相同的代码，并且两者都需要一个终止条件（避免无限循环，或者在这种情况下更确切地说是无限递归）。

将递归算法转换为非递归算法是可能的，不过逻辑上通常会更加复杂，而且需要使用栈。

事实上，递归本身就使用了栈：函数栈。

### 嵌套函数和闭包

你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。

它自身也形成了一个*闭包*（closure）。闭包是可以拥有独立变量以及绑定了这些变量的环境（“封闭”了表达式）的表达式（通常是函数）。

既然嵌套函数是一个闭包，就意味着一个嵌套函数可以“继承”容器函数的参数和变量。换句话说，内部函数包含外部函数的作用域。

总结如下：

- 内部函数只可以在外部函数中访问。
- 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。

函数可以被多层嵌套。

**命名冲突**

当同一个闭包作用域下两个参数或者变量同名时，就会产生*命名冲突*。

更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。

链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域。

### 闭包

闭包是 JavaScript 中最强大的特性之一。

JavaScript 允许函数嵌套，并且内部函数具有定义在外部函数中的所有变量和函数（以及外部函数能访问的所有变量和函数）的完全访问权限。

但是，外部函数却*不能*访问定义在内部函数中的变量和函数。这给内部函数的变量提供了一种封装。

此外，由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，外部函数中定义的变量和函数的生存周期将比内部函数执行的持续时间要长。

当内部函数以某一种方式被任何一个外部函数之外的任何作用域访问时，就会创建闭包。

**备注：**使用闭包时需要注意许多陷阱！

如果一个闭包的函数定义了一个和外部的某个变量名称相同的变量，那么这个闭包将无法引用外部作用域中的这个变量。（内部作用域的变量“覆盖”外部作用域，直至程序退出内部作用域。可以将其视作命名冲突。）

### 使用 arguments 对象

函数的实际参数会被保存在一个类似数组的 arguments 对象中。

在函数内，你可以按如下方式找出传入的参数：

```js
arguments[i];
```

其中 `i` 是参数的序号，从 `0` 开始。所以第一个传入函数的参数会是 `arguments[0]`。

参数的数量由 `arguments.length` 表示。

使用 `arguments` 对象，你可以处理比声明更多的参数来调用函数。这在你事先不知道会需要将多少参数传递给函数时十分有用。

你可以用 `arguments.length` 来获得实际传递给函数的参数的数量，然后用 `arguments` 对象来访问每个参数。

**备注：** `arguments` 变量只是“类数组”，而不是数组。它与数组类似，有索引编号和 `length` 属性。尽管如此，它并不*具备* Array 对象的所有数组操作方法。

### 函数参数

有两种特殊的参数语法：*默认参数*和*剩余参数*。

**默认参数**

在 JavaScript 中，函数参数的默认值是 `undefined`。

然而，在某些情况下设置不同的默认值可能会很有用。这正是默认参数的作用。

**剩余参数**

剩余参数语法允许将不确定数量的参数表示为数组。

### 箭头函数

箭头函数表达式（也称*胖箭头*，以区分未来 JavaScript 中假设的 `->` 语法）相比函数表达式具有较短的语法且没有它自己的 `this`、`arguments`、`super`和 `new.target`。

箭头函数总是匿名的。

有两个因素会影响对箭头函数的引入：*更简洁的函数*和 `this` 的*无绑定性*。

**更简洁的函数**

在一些函数模式中，更简洁的函数很受欢迎。

**无单独的 this**

在箭头函数出现之前，每一个新函数都定义了自己的 this`值（在构造函数中是一个新的对象；在严格模式下是 undefined；在作为“对象方法”调用的函数中指向这个对象；等等）。

事实证明，这对于面向对象的编程风格来说并不理想。

在 ECMAScript 3/5 中，通过把 `this` 的值赋值给一个变量可以修复这个问题。

**箭头函数没有自己的 `this`，而是使用封闭执行上下文的 `this` 值。**

### 预定义函数

JavaScript 语言有几个顶级的内置函数：

- `eval()`
  - **`eval()`** 方法执行方法计算以字符串表示的 JavaScript 代码。

- `isFinite()`
  - **`isFinite()`** 全局函数判断传入的值是否是有限的数值。如果需要的话，其参数首先被转换为一个数值。

- `isNaN()`
  - **`isNaN()`** 函数判断一个值是否是 `NaN`。
  - 注意：`isNaN` 函数内部的强制转换规则十分有趣。
  - 你也可以使用 `Number.isNaN()`来判断该值是否为 NaN。

- `parseFloat()`
  - **`parseFloat()`** 函数解析字符串参数，并返回一个浮点数。

- `parseInt()`
  - **`parseInt()`** 函数解析字符串参数，并返回指定的基数（基础数学中的数制）的整数。

- `decodeURI()`
  - **`decodeURI()`** 函数对先前经过 `encodeURI` 函数或者其他类似方法编码过的统一资源标志符（URI）进行解码。

- `decodeURIComponent()`
  - **`decodeURIComponent()`** 方法对先前经过 `encodeURIComponent`函数或者其他类似方法编码的统一资源标志符（URI）进行解码。

- `encodeURI()`
  - **`encodeURI()`** 方法通过以表示字符的 UTF-8 编码的一个、两个、三个或四个转义序列替换统一资源标识符（URI）的某些字符来进行编码（对于由两个“代理（surrogate）”字符组成的字符，只会编码为四个转义序列）。

- `encodeURIComponent()`
  - **`encodeURIComponent()`** 方法通过以表示字符的 UTF-8 编码的一个、两个、三个或四个转义序列替换统一资源标识符（URI）的某些字符来进行编码（对于由两个“代理”字符组成的字符，只会编码为四个转义序列）。



## 5.表达式与运算符

### 运算符

JavaScript 拥有如下类型的运算符。

- 赋值运算符（Assignment operators）

  - 赋值运算符将它右边操作数的值赋给它左边的操作数。最简单的赋值运算符是等于（`=`），它将右边的操作数值赋给左边的操作数。

  - 复合赋值操作符

    | 名字             | 简写的运算符 | 含义             |
    | :--------------- | :----------- | :--------------- |
    | 赋值             | `x = y`      | `x = y`          |
    | 加法赋值         | `x += y`     | `x = x + y`      |
    | 减法赋值         | `x -= y`     | `x = x - y`      |
    | 乘法赋值         | `x *= y`     | `x = x * y`      |
    | 除法赋值         | `x /= y`     | `x = x / y`      |
    | 求余赋值         | `x %= y`     | `x = x % y`      |
    | 求幂赋值         | `x **= y`    | `x = x ** y`     |
    | 左移位赋值       | `x <<= y`    | `x = x << y`     |
    | 右移位赋值       | `x >>= y`    | `x = x >> y`     |
    | 无符号右移位赋值 | `x >>>= y`   | `x = x >>> y`    |
    | 按位与赋值       | `x &= y`     | `x = x & y`      |
    | 按位异或赋值     | `x ^= y`     | `x = x ^ y`      |
    | 按位或赋值       | `x |= y`     | `x = x | y`      |
    | 逻辑与赋值       | `x &&= f()`  | `x && (x = f())` |
    | 逻辑或赋值       | `x ||= f()`  | `x || (x = f())` |
    | 逻辑空赋值       | `x ??= f()`  | `x ?? (x = f())` |

  - 对于更复杂的赋值，解构赋值语法是一个能从数组或对象对应的数组结构或对象字面量里提取数据的 Javascript 表达式。

- 比较运算符（Comparison operators）

  - 比较运算符比较它的操作数并返回一个基于表达式是否为真的逻辑值。

  - 操作数可以是数字，字符串，逻辑，对象值。

  - 字符串比较是基于标准的字典顺序，使用 Unicode 值。

  - 在多数情况下，如果两个操作数不是相同的类型，JavaScript 会尝试转换它们为恰当的类型来比较。这种行为通常发生在数字作为操作数的比较。

  - 类型转换的例外是使用 `===` 和 `!==` 操作符，它们会执行严格的相等和不相等比较。这些运算符不会在检查相等之前转换操作数的类型。

    | 运算符                                | 描述                                        | 返回 true 的示例                     |
    | :------------------------------------ | :------------------------------------------ | :----------------------------------- |
    | 等于 Equal(`==`)                      | 如果两边操作数相等时返回 true。             | `3 == var1` `"3" == var1` `3 == '3'` |
    | 不等于 Not equal (`!=`)               | 如果两边操作数不相等时返回 true             | `var1 != 4 var2 != "3"`              |
    | 全等 Strict equal(`===`)              | 两边操作数相等且类型相同时返回 true。       | `3 === var1`                         |
    | 不全等 Strict not equal(`!==`)        | 两边操作数不相等或类型不同时返回 true。     | `var1 !== "3" 3 !== '3'`             |
    | 大于 Greater than(`>`)                | 左边的操作数大于右边的操作数返回 true       | `var2 > var1 "12" > 2`               |
    | 大于等于 Greater than or equal (`>=`) | 左边的操作数大于或等于右边的操作数返回 true | `var2 >= var1 var1 >= 3`             |
    | 小于 Less than(`<`)                   | 左边的操作数小于右边的操作数返回 true       | `var1 < var2 "2" < 12`               |
    | 小于等于 Less than or equal(`<=`)     | 左边的操作数小于或等于右边的操作数返回 true | `var1 <= var2 var2 <= 5`             |

  - **备注：**（**=>**）不是运算符，而是箭头函数的标记符号。

- 算数运算符（Arithmetic operators）

  - 算术运算符使用数值 (字面量或者变量) 作为操作数并返回一个数值。

  - 标准的算术运算符就是加减乘除 (+ - * /)。

  - 当操作数是浮点数时，这些运算符表现得跟它们在大多数编程语言中一样（特殊要注意的是，除零会产生`Infinity`）。

    | 运算符            | 描述                                                         | 示例                                                         |
    | :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
    | 求余（`%`）       | 二元运算符。返回相除之后的余数。                             | 12 % 5 返回 2。                                              |
    | 自增（`++`）      | 一元运算符。将操作数的值加一。如果放在操作数前面（`++x`），则返回加一后的值；如果放在操作数后面（`x++`），则返回操作数原值，然后再将操作数加一。 | `var x=3;` `console.log(++x); //4` `console.log(x); //4` `var y=3;` `console.log(y++); //3` `console.log(y); //4` |
    | 自减（`--`）      | 一元运算符。将操作数的值减一。前后缀两种用法的返回值类似自增运算符。 | var x=3; console.log(--x); //输入 2,x=2var y=3;console.log(y--);//输出 3,x=2; |
    | 一元负值符（`-`） | 一元运算符，返回操作数的负值。                               | var x=3; console.log(-x); //输入 -3                          |
    | 一元正值符（+）   | 一元运算符，如果操作数在之前不是数值，试图将其转换为数值。   | `console.log( +'3' ); // 3` `console.log( '3' ); // '3'` `console.log(+true); // 1` |
    | 指数运算符（**）  | 计算底数（`base`）的指数（`exponent`）次方，表示为 `base^exponent`。 | `2 ** 3` 返回 `8`。`10 ** -1` 返回 `0.1`。                   |

- 位运算符（Bitwise operators）

  - 位运算符将它的操作数视为 32 位元的二进制串（0 和 1 组成）而非十进制八进制或十六进制数。

    | Operator                         | Usage     | Description                                                  |
    | :------------------------------- | :-------- | :----------------------------------------------------------- |
    | 按位与 AND                       | `a & b`   | 在 a,b 的位表示中，每一个对应的位都为 1 则返回 1，否则返回 0. |
    | 按位或 OR                        | `a | b`   | 在 a,b 的位表示中，每一个对应的位，只要有一个为 1 则返回 1，否则返回 0. |
    | 按位异或 XOR                     | `a ^ b`   | 在 a,b 的位表示中，每一个对应的位，两个不相同则返回 1，相同则返回 0. |
    | 按位非 NOT                       | `~ a`     | 反转被操作数的位。                                           |
    | 左移 shift                       | `a << b`  | 将 a 的二进制串向左移动 b 位，右边移入 0.                    |
    | 算术右移                         | `a >> b`  | 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位。(译注：算术右移左边空出的位是根据最高位是 0 和 1 来进行填充的) |
    | 无符号右移 (左边空出位用 0 填充) | `a >>> b` | 把 a 的二进制表示向右移动 b 位，丢弃被移出的所有位，并把左边空出的位都填充为 0 |

  - 位逻辑运算符

  - | 表达式   | 结果  | 二进制描述                                        |
    | :------- | :---- | :------------------------------------------------ |
    | `15 & 9` | `9`   | `1111 & 1001 = 1001`                              |
    | `15 | 9` | `15`  | `1111 | 1001 = 1111`                              |
    | `15 ^ 9` | `6`   | `1111 ^ 1001 = 0110`                              |
    | `~15`    | `-16` | `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` |
    | `~9`     | `-10` | `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` |

  - 移位运算符

  - | 运算符             | 描述                                                         | 示例                                                         |
    | :----------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
    | `<<`（左移位）     | 将第一个操作数向左移动指定数量的位。左边移出位被抛弃。左边移出的几位被丢弃。右边多出的空位由 0 补齐。 | `9<<2` 产生 36，因为 1001 移位 2 比特向左变为 100100，它是 36。 |
    | `>>`（带符号右移） | 将第一个操作数向右移动指定数量的位。右边移出位被抛弃。左边多出的空位由原值的最左边数字补齐。 | `9>>2` 产生 2，因为 1001 移位 2 位向右变为 10，其是 2。同样，`-9>>2` 产生 -3，由于符号被保留。 |
    | `>>>`（补零右移）  | 将第一个操作数向右移动指定数量的位。右边移出位被抛弃。左边多出的空位由 0 补齐。 | `19>>>2`产生 4，因为 10011 移位 2 位向右变为 100，它是 4。对非负数值，补零右移和带符号右移产生相同结果。 |

- 逻辑运算符（Logical operators）

  - 逻辑运算符常用于布尔（逻辑）值之间; 当操作数都是布尔值时，返回值也是布尔值。

  - 不过实际上`&&`和`||`返回的是一个特定的操作数的值，所以当它用于非布尔值的时候，返回值就可能是非布尔值。

  - | 运算符       | 范例             | 描述                                                         |
    | :----------- | :--------------- | :----------------------------------------------------------- |
    | 逻辑与`(&&`) | `expr1 && expr2` | (逻辑与) 如果 expr1 能被转换为 false，那么返回 expr1；否则，返回`expr2`。因此`，&&`用于布尔值时，当操作数都为 true 时返回 true；否则返回 false. |
    | 逻辑或(`||`) | `expr1 || expr2` | (逻辑或) 如果 expr1 能被转换为 true，那么返回 expr1；否则，返回`expr2`。因此，\|\| 用于布尔值时，当任何一个操作数为 true 则返回 true；如果操作数都是 false 则返回 false。 |
    | 逻辑非 `(!)` | `!expr`          | (逻辑非) 如果操作数能够转换为 true 则返回 false；否则返回 true。 |

  - 能被转换为`false`的值有`null`, `0`, `NaN`, 空字符串 ("") 和`undefined`。

  - **短路求值**

    - `false` && *anything* // 被短路求值为 false
    - `true` || *anything* // 被短路求值为 true
    - 逻辑的规则，保证这些评估是总是正确的。请注意，上述表达式的`anything`部分不会被求值，所以这样做不会产生任何副作用。

- 字符串运算符（String operators）

  - 除了比较操作符，它可以在字符串值中使用，连接操作符（+）连接两个字符串值相连接，返回另一个字符串，它是两个操作数串的结合。
  - 简写操作符 `+=` 也可以用来拼接字符串

- 条件（三元）运算符（Conditional operator）

  - 条件运算符是 JavaScript 中唯一需要三个操作数的运算符。
  - 运算的结果根据给定条件在两个值中取其一。
  - `条件 ? 值 1 : 值 2`
  - 如果`条件`为真，则结果取`值 1`。否则为`值 2`。
  - 你能够在任何允许使用标准运算符的地方使用条件运算符。

- 逗号运算符（Comma operator）

  - 逗号操作符对两个操作数进行求值并返回最终操作数的值。
  - 它常常用在 `for` 循环中，在每次循环时对多个变量进行更新。

- 一元运算符（Unary operators）

  - 一元操作符仅对应一个操作数。
  - `x++`
  - 二元运算符：`a + b`
  - `delete`操作符，删除一个对象的属性或者一个数组中某一个键值。
    - 删除数组中的元素时，数组的长度是不变的，虽存在，但值变成了`undefined`
  - typeof 操作符
    - `typeof operand;`
    - `typeof (operand);`
    - typeof 操作符返回一个表示 operand 类型的字符串值。
    - operand 可为字符串、变量、关键词或对象，其类型将被返回。
    - operand 两侧的括号为可选。
  - void 运算符
    - void 运算符，表明一个运算没有返回值。

- 关系运算符（Relational operator）

  - 关系运算符对操作数进行比较，根据比较结果真或假，返回相应的布尔值。
  - `in`操作符，如果所指定的**属性**确实存在于所指定的对象中，则会返回`true`
    - `propNameOrNumber in objectName;`
    - 在这里 `propNameOrNumber`可以是一个代表着属性名的字符串或者是一个代表着数组索引的数值表达式，而`objectName`则是一个对象名。
  - `instanceof`
    - 如果所判别的对象确实是所指定的类型，则返回`true`。
    - `objectName instanceof objectType;`
    - `objectName` 是需要做判别的对象的名称，而`objectType`是假定的对象的类型，例如`Date`或 `Array`

**运算符优先级**

运算符的优先级，用于确定一个表达式的计算顺序。

在你不能确定优先级时，可以通过使用括号显式声明运算符的优先级。

下表列出了描述符的优先级，从最高到最低。

| Operator type          | Individual operators                     |
| :--------------------- | :--------------------------------------- |
| member                 | `. []`                                   |
| call / create instance | `() new`                                 |
| negation/increment     | `! ~ - + ++ -- typeof void delete`       |
| multiply/divide        | `* / %`                                  |
| addition/subtraction   | `+ -`                                    |
| bitwise shift          | `<< >> >>>`                              |
| relational             | `< <= > >= in instanceof`                |
| equality               | `== != === !==`                          |
| bitwise-and            | `&`                                      |
| bitwise-xor            | `^`                                      |
| bitwise-or             | `|`                                      |
| logical-and            | `&&`                                     |
| logical-or             | `||`                                     |
| conditional            | `?:`                                     |
| assignment             | `= += -= *= /= %= <<= >>= >>>= &= ^= |=` |
| comma                  | `,`                                      |

### 表达式

表达式是一组代码的集合，它返回一个值。

每一个合法的表达式都能计算成某个值，但从概念上讲，有两种类型的表达式：有副作用的（比如赋值）和单纯计算求值的。

JavaScript 有以下表达式类型：

- 算数：得出一个数字，例如 3.14159。（通常使用算数运算符）
- 字符串：得出一个字符串，例如，"Fred" 或 "234"。（通常使用字符串运算符。）
- 逻辑值：得出 true 或者 false。（经常涉及到逻辑运算符。）
- 基本表达式：javascript 中基本的关键字和一般表达式。
- 左值表达式：分配给左值。

**基本表达式**

`this`，用于指代当前的对象，通常，`this`指代的是方法中正在被调用的对象。

你可以在任何表单元素的`onchange`事件处理中调用`validat`函数，用`this`来指代当前的表单元素。

分组操作符（）控制了表达式中计算的优先级。

左值可以作为赋值的目标。

可以使用new` 运算符创建一个自定义类型或者是预置类型的对象实例。

然后，赋给左值。

super关键字可以用来调用一个对象父类的函数，它在用来调用一个类的父类的构造函数时非常有用。

## 6.数字和日期

在 JavaScript 里面，数字均为双精度浮点类型，即一个介于 ±2^−1023 和 ±2^+1024 之间的数字，或约为 ±10^−308 到 ±10^+308，数字精度为 53 位。整数数值仅在 ±(2^53 - 1) 的范围内可以表示准确。

除了能够表示浮点数，数字类型也还能表示三种符号值：

- `+Infinity`（正无穷）

- `-Infinity`（负无穷）

- `NaN` not-a-number，非数字

**你可以使用四种数字进制：十进制、二进制、八进制和十六进制。**

注意，十进制可以以 0 开头，后面接其他十进制数字，但是假如下一个接的十进制数字小于 8，那么该数字将会被当做八进制处理。

二进制数字语法是以零为开头，后面接一个小写或大写的拉丁文字母 B(`0b` 或者是 `0B`)。

八进制数字语法是以 0 为开头的。假如 0 后面的数字不在 0 到 7 的范围内，该数字将会被转换成十进制数字。

十六进制数字语法是以零为开头，后面接一个小写或大写的拉丁文字母 X(`0x 或者是 0X`)。

**指数**

`5e1` 50

`175e-2` 1.75

**数字对象**

内置的 `Number`对象有一些有关数字的常量属性，如最大值、不是一个数字和无穷大的。

```js
const biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY; //正无穷
const negInfiniteNum = Number.NEGATIVE_INFINITY; //负无穷
const notANum = Number.NaN;
```

`Math`对象

```js
Math.PI; // π
```

**日期对象**

JavaScript 没有日期数据类型。但是你可以在你的程序里使用`Date`对象和其方法来处理日期和时间。

创建一个日期对象：

```js
var dateObjectName = new Date([parameters]);
```

参数（parameters）：

- 无参数 : 创建今天的日期和时间
  - 例如： `today = new Date();`
- 一个符合以下格式的表示日期的字符串："月 日，年 时：分：秒"
  - 例如： `var Xmas95 = new Date("December 25, 1995 13:30:00")`
  - 如果省略时、分、秒，那么他们的值将被设置为 0
- 一个年，月，日的整型值的集合
  - 例如： `var Xmas95 = new Date(1995, 11, 25)`
- 一个年，月，日，时，分，秒的集合
  - 例如： `var Xmas95 = new Date(1995, 11, 25, 9, 30, 0);`

方法：

- "set" 方法，用于设置 Date 对象的日期和时间的值。
- "get" 方法，用于获取 Date 对象的日期和时间的值。
- "to" 方法，用于返回 Date 对象的字符串格式的值。
- parse 和 UTC 方法，用于解析 Date 字符串。

还有个 getDay 方法可以返回星期，但是没有相应的 setDay 方法用来设置星期，因为星期是自动设置的。

## 7.文本格式化

### 字符串

JavaScript 中的`String`类型用于表示文本型的数据。

它是由无符号整数值（16bit）作为元素而组成的集合。

字符串中的每个元素在字符串中占据一个位置。

第一个元素的 index 值是 0，下一个元素的 index 值是 1，以此类推。

字符串的长度就是字符串中所含的元素个数。

**字面量：**使用单引号或双引号创建简单的字符串。

**16 进制转义序列：**\x 之后的数值将被认为是一个 16 进制数。

**Unicode 转义序列：**Unicode 转义序列在\u 之后需要至少 4 个字符。

**Unicode 字元逸出：**这是 ECMAScript 6 中的新特性。有了 Unicode 字元逸出，任何字符都可以用 16 进制数转义，这使得通过 Unicode 转义表示大于`0x10FFFF`的字符成为可能。

**字符串对象**

`String` 对象是对原始 string 类型的封装

`String` 对象有一个属性 `length`，标识了字符串中 UTF-16 的码点个数。即，长度。

`String` 对象的方法：

| 方法                                  | 描述                                                         |
| :------------------------------------ | :----------------------------------------------------------- |
| `charAt`, `charCodeAt`, `codePointAt` | 返回字符串指定位置的字符或者字符编码。                       |
| `indexOf`, `lastIndexOf`              | 分别返回字符串中指定子串的位置或最后位置。                   |
| `startsWith` `endsWith`, `includes`   | 返回字符串是否以指定字符串开始、结束或包含指定字符串。       |
| `concat`                              | 连接两个字符串并返回新的字符串。                             |
| `fromCharCode`, `fromCodePoint`       | 从指定的 Unicode 值序列构造一个字符串。这是一个 String 类方法，不是实例方法。 |
| `split`                               | 通过将字符串分离成一个个子串来把一个 String 对象分裂到一个字符串数组中。 |
| `slice`                               | 从一个字符串提取片段并作为新字符串返回。                     |
| `substring`, `substr`                 | 分别通过指定起始和结束位置，起始位置和长度来返回字符串的指定子集。 |
| `match` `replace`, `search`           | 通过正则表达式来工作。                                       |
| `toLowerCase`, `toUpperCase`          | 分别返回字符串的小写表示和大写表示。                         |
| `normalize`                           | 按照指定的一种 Unicode 正规形式将当前字符串正规化。          |
| `repeat`                              | 将字符串内容重复指定次数后返回。                             |
| `trim`                                | 去掉字符串开头和结尾的空白字符。                             |

**多行模版字符串**

模板字符串是一种允许内嵌表达式的 String 字面值。可以用它实现多行字符串或者字符串内插等特性。

多行的字符串，`\n` 或者 ``

**嵌入表达式**

`+`

现在，使用模板字符串，可以使用语法糖让类似功能的实现代码更具可读性

模版字符串即 `` ，例如：

```js
const five = 5;
const ten = 10;
console.log(`Fifteen is ${five + ten} and not ${2 * five + ten}.`);
// "Fifteen is 15 and not 20."
```

### 国际化

`Intl`对象是 ECMAScript 国际化 API 的命名空间，它提供了语言敏感的字符串比较，数字格式化和日期时间格式化功能。

`Collator`, `NumberFormat`, 和 `DateTimeFormat`对象的构造函数是`Intl`对象的属性。

上面三个分别是：定序、数字格式化、日期和时间格式化

## 8.正则表达式

正则表达式是用于匹配字符串中字符组合的模式。

在 JavaScript 中，正则表达式也是对象。

这些模式被用于 `RegExp`的 `exec`和 `test`方法，以及 `String`的 `match`、`matchAll`、`replace`、`search`和 `split`方法。

**创建一个正则表达式**

- 使用一个正则表达式字面量，其由包含在斜杠之间的模式组成。

```js
var re = /ab+c/;
```

- 调用`RegExp`对象的构造函数。

```js
var re = new RegExp("ab+c");
```

在脚本运行过程中，用构造函数创建的正则表达式会被编译。

如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式。

**编写一个正则表达式**

一个正则表达式模式是由简单的字符，或者是简单和特殊字符的组合构成的。

- 断言
- 字符类
- 组合与反向引用
- 量词

<center>正则表达式中的特殊字符</center>

| 字符                  | 含义                                                         |
| :-------------------- | :----------------------------------------------------------- |
| `\`                   | 依照下列规则匹配：<br />在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。<br />例如，<br />前面没有 "`\`" 的 "b" 通常匹配小写字母 "b"，即字符会被作为字面理解，无论它出现在哪里。<br />但如果前面加了 "`\`"，它将不再匹配任何字符，而是表示一个**字符边界**。<br />在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。即 "**转义（Escaping）**" 。<br />如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。<br />所以为了在模式中添加一个反斜杠，你需要在字符串字面量中转义它。<br />`/[a-z]\s/i` 和 `new RegExp("[a-z]\\s", "i")` 创建了相同的正则表达式：<br />一个用于搜索后面紧跟着空白字符（`\s` 可看后文）并且在 a-z 范围内的任意字符的表达式。<br />为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。<br />例如 `/[a-z]:\\/i` 和 `new RegExp("[a-z]:\\\\","i")` 会创建相同的表达式，即匹配类似 "C:`\`" 字符串。 |
| `^`                   | 匹配输入的开始。<br />如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。<br />例如，`/^A/` 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。<br />当 '`^`' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。 |
| `$`                   | 匹配输入的结束。<br />如果多行标志被设置为 true，那么也匹配换行符前的位置。<br />例如，`/t$/` 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。 |
| `*`                   | 匹配前一个表达式 0 次或多次。等价于 `{0,}`。<br />例如，`/bo*/` 会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中不会匹配任何内容。 |
| `+`                   | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`。<br />例如，`/a+/` 会匹配 "candy" 中的 'a' 和 "caaaaaaandy" 中所有的 'a'，但是在 "cndy" 中不会匹配任何内容。 |
| `?`                   | 匹配前面一个表达式 0 次或者 1 次。等价于 `{0,1}`。<br />例如，`/e?le?/` 匹配 "angel" 中的 'el'、"angle" 中的 'le' 以及 "oslo' 中的 'l'。<br />如果**紧跟在任何量词 \*、 +、? 或 {} 的后面**，将会使量词变为**非贪婪**（匹配尽量少的字符），和缺省使用的**贪婪模式**（匹配尽可能多的字符）正好相反。<br />例如，对 "123abc" 使用 `/\d+/` 将会匹配 "123"，而使用 `/\d+?/` 则只会匹配到 "1"。<br />还用于先行断言中，如本表的 `x(?=y)` 和 `x(?!y)` 条目所述。 |
| `.`                   | （小数点）默认匹配除换行符之外的任何单个字符。<br />例如，`/.n/` 将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。<br />如果 `s` ("dotAll") 标志位被设为 true，它也会匹配换行符。 |
| `(x)`                 | 像下面的例子展示的那样，它会匹配 'x' 并且记住匹配项。<br />其中括号被称为*捕获括号*。<br />模式 `/(foo) (bar) \1 \2/` 中的 '`(foo)`' 和 '`(bar)`' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。<br />模式中的 `\1` 和 `\2` 表示第一个和第二个被捕获括号匹配的子字符串，即 `foo` 和 `bar`，匹配了原字符串中的后两个单词。<br />注意 `\1`、`\2`、...、`\n` 是用在正则表达式的匹配环节，详情可以参阅后文的 `\n`条目。<br />而在正则表达式的替换环节，则要使用像 `$1`、`$2`、...、`$n` 这样的语法，例如，`'bar foo'.replace(/(...) (...)/, '$2 $1')`。`$&` 表示整个用于匹配的原字符串。 |
| `(?:x)`               | 匹配 'x' 但是不记住匹配项。<br />这种括号叫作*非捕获括号*，使得你能够定义与正则表达式运算符一起使用的子表达式。<br />看看这个例子 `/(?:foo){1,2}/`。<br />如果表达式是 `/foo{1,2}/`，`{1,2}` 将只应用于 'foo' 的最后一个字符 'o'。<br />如果使用非捕获括号，则 `{1,2}` 会应用于整个 'foo' 单词。<br />更多信息，可以参阅下文的`使用括号的子字符串匹配`条目。 |
| `x(?=y)`              | 匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。<br />例如，`/Jack(?=Sprat)/`会匹配到'Jack'仅当它后面跟着'Sprat'。<br />`/Jack(?=Sprat|Frost)/`匹配‘Jack’仅当它后面跟着'Sprat'或者是‘Frost’。<br />但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 |
| `(?<=y)x`             | 匹配'x'仅当'x'前面是'y'.这种叫做后行断言。<br />例如，`/(?<=Jack)Sprat/`会匹配到' Sprat '仅仅当它前面是' Jack '。<br />`/(?<=Jack|Tom)Sprat/`匹配‘Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。<br />但是‘Jack’和‘Tom’都不是匹配结果的一部分。 |
| `x(?!y)`              | 仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。<br />例如，仅仅当这个数字后面没有跟小数点的时候，`/\d+(?!\.)/` 匹配一个数字。<br />正则表达式`/\d+(?!\.)/.exec("3.141") `匹配‘141’而不是‘3.141’ |
| `(?<!y)x`             | 仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找。<br />例如，仅仅当这个数字前面没有负号的时候，`/(?<!-)\d+/` 匹配一个数字。<br /> `/(?<!-)\d+/.exec('3')` 匹配到 "3".<br /> `/(?<!-)\d+/.exec('-3')` 因为这个数字前有负号，所以没有匹配到。 |
| `x|y`                 | 匹配‘x’或者‘y’。<br />例如，`/green|red/`匹配“green apple”中的‘green’和“red apple”中的‘red’ |
| `{n}`                 | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 <br />比如， `/a{2}/ `不会匹配“candy”中的'a',但是会匹配“caandy”中所有的 a，以及“caaandy”中的前两个'a'。 |
| `{n,}`                | n 是一个正整数，匹配前一个字符至少出现了 n 次。<br />例如，`/a{2,}/` 匹配 "aa", "aaaa" 和 "aaaaa" 但是不匹配 "a"。 |
| `{n,m}`               | n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。<br />如果 n 或者 m 的值是 0，这个值被忽略。<br />例如，`/a{1, 3}/` 并不匹配“cndy”中的任意字符，匹配“candy”中的 a，匹配“caandy”中的前两个 a，也匹配“caaaaaaandy”中的前三个 a。<br />注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的 a。 |
| `[xyz\]`              | 一个字符集合。匹配方括号中的任意字符，包括**转义序列**。<br />你可以使用破折号（-）来指定一个字符范围。<br />对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。<br /> 例如，`[abcd]`和 `[a-d]` 是一样的。<br />他们都匹配"brisket"中的‘b’,也都匹配“city”中的‘c’。`/[a-z.]+/` 和`/[\w.]+/`与字符串“test.i.ng”匹配。 |
| `[^xyz\]`             | 一个反向字符集。<br />也就是说， 它匹配任何没有包含在方括号中的字符。<br />你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br />例如，`[^abc]` 和 `[^a-c]` 是一样的。<br />他们匹配"brisket"中的‘r’，也匹配“chop”中的‘h’。 |
| `[\b\]`               | 匹配一个退格 (U+0008)。（不要和\b混淆了。）                  |
| `\b`                  | 匹配一个词的边界。<br />一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。<br />注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是 0。（不要和 [\b] 混淆了）<br />使用"moon"举例：<br />`/\bm/`匹配“moon”中的‘m’； <br />`/oo\b/`并不匹配"moon"中的'oo'，因为'oo'被一个“字”字符'n'紧跟着。<br />`/oon\b/`匹配"moon"中的'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。<br />` /\w\b\w/`将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。<br />**备注：** JavaScript 的正则表达式引擎将**特定的字符集**定义为“字”字符。不在该集合中的任何字符都被认为是一个断词。这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 |
| `\B`                  | 匹配一个非单词边界。<br />匹配如下几种情况：字符串第一个字符为非“字”字符字符串最后一个字符为非“字”字符两个单词字符之间两个非单词字符之间空字符串。<br />例如，<br />`/\B../`匹配"noonday"中的'oo', <br />`/y\B../`匹配"possibly yesterday"中的’yes‘ |
| `\cX`                 | 当 X 是处于 A 到 Z 之间的字符的时候，匹配字符串中的一个控制符。<br />例如，`/\cM/` 匹配字符串中的 control-M (U+000D)。 |
| `\d`                  | 匹配一个数字。<br />`\d`等价于`[0-9]`。<br />例如， `/\d/` 或者 `/[0-9]/` 匹配"B2 is the suite number."中的'2'。 |
| `\D`                  | 匹配一个非数字字符。<br />`\D`等价于 `[^0-9]`。<br />例如， `/\D/` 或者 `/[^0-9]/` 匹配"B2 is the suite number."中的'B' 。 |
| `\f`                  | 匹配一个换页符 (U+000C)。                                    |
| `\n`                  | 匹配一个换行符 (U+000A)。                                    |
| `\r`                  | 匹配一个回车符 (U+000D)。                                    |
| `\s`                  | 匹配一个空白字符，包括空格、制表符、换页符和换行符。<br />等价于 `[\f\n\r\t\v\u0020\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`。<br />例如，`/\s\w*/` 匹配"foo bar."中的' bar'。<br />经测试，`\s`不匹配"`\u180e`"，在当前版本 Chrome(v80.0.3987.122) 和 Firefox(76.0.1) 控制台输入/\s/.test("\u180e") 均返回 false。 |
| `\S`                  | 匹配一个非空白字符。<br />等价于 `[^\f\n\r\t\v\u0020\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]`。<br />例如，`/\S\w*/` 匹配"foo bar."中的'foo'。 |
| `\t`                  | 匹配一个水平制表符 (U+0009)。                                |
| `\v`                  | 匹配一个垂直制表符 (U+000B)。                                |
| `\w`                  | 匹配一个单字字符（字母、数字或者下划线）。<br />等价于 `[A-Za-z0-9_]`。<br />例如，`/\w/` 匹配 "apple," 中的 'a'，"$5.28,"中的 '5' 和 "3D." 中的 '3'。 |
| `\W`                  | 匹配一个非单字字符。<br />等价于 `[^A-Za-z0-9_]`。<br />例如，`/\W/` 或者 `/[^A-Za-z0-9_]/` 匹配 "50%." 中的 '%'。 |
| `\n`                  | 在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串 (捕获的数目以左括号计数)。<br />比如 `/apple(,)\sorange\1/` 匹配"apple, orange, cherry, peach."中的'apple, orange,' 。 |
| `\0`                  | 匹配 NULL（U+0000）字符，不要在这后面跟其他小数，因为 `\0` 是一个八进制转义序列。`\0<digits>` |
| `\xhh`                | 匹配一个两位十六进制数（\x00-\xFF）表示的字符。              |
| `\uhhhh`              | 匹配一个四位十六进制数表示的 UTF-16 代码单元。               |
| `\u{hhhh}或\u{hhhhh}` | （仅当设置了 u 标志时）匹配一个十六进制数表示的 Unicode 字符。 |

**使用正则表达式**

RegExp对象：

- exec
- test

String对象：

- match
- replace
- search
- split

| 方法       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| `exec`     | 一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组（未匹配到则返回 null）。 |
| `test`     | 一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或 false。 |
| `match`    | 一个在字符串中执行查找匹配的 String 方法，它返回一个数组，在未匹配到时会返回 null。 |
| `matchAll` | 一个在字符串中执行查找所有匹配的 String 方法，它返回一个迭代器（iterator）。 |
| `search`   | 一个在字符串中测试匹配的 String 方法，它返回匹配到的位置索引，或者在失败时返回 -1。 |
| `replace`  | 一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉匹配到的子字符串。 |
| `split`    | 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 `String` 方法。 |

当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法；

想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。

如果你使用 exec 或 match 方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象。如果匹配失败，那么 exec 方法返回 null（也就是 false）。

**通过标志进行高级搜索**

正则表达式有六个可选参数 (`flags`) 允许全局和不分大小写搜索等。这些参数既可以单独使用也能以任意顺序一起使用，并且被包含在正则表达式实例中。

| 标志 | 描述                                                        |
| :--- | :---------------------------------------------------------- |
| `g`  | 全局搜索。                                                  |
| `i`  | 不区分大小写搜索。                                          |
| `m`  | 多行搜索。                                                  |
| `s`  | 允许 `.` 匹配换行符。                                       |
| `u`  | 使用 unicode 码的模式进行匹配。                             |
| `y`  | 执行“粘性 (`sticky`)”搜索，匹配从目标字符串的当前位置开始。 |

语法：

```js
var re = /pattern/flags;
```

将用户输入转义为正则表达式中的一个字面字符串，可以通过简单的替换来实现：

```js
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  //$&表示整个被匹配的字符串
}
```

## 9.索引集合

按索引值排序的数据集合。

数组、类数组结构

*数组*是由名称和索引引用的值构成的有序列表。

### 创建数组

```js
const arr1 = new Array(element0, element1, /* … ,*/ elementN);
const arr2 = Array(element0, element1, /* … ,*/ elementN);
const arr3 = [element0, element1, /* … ,*/ elementN];
```

括号语法称为“数组字面量”或“数组初始化式”。

创建一个长度不为 0，但是又没有任何元素的数组：

```js
// 这种方式...
const arr1 = new Array(arrayLength);

// ...与这种方式会形成相同数组
const arr2 = Array(arrayLength);

// 这个效果也一样
const arr3 = [];
arr3.length = arrayLength;
```

**备注：**以上代码，`arrayLength` 必须为一个 `Number`。否则，将会创建一个只有单个元素（内含提供的值）的数组。调用 `arr.length` 会返回 `arrayLength`，但数组不包含任何元素。`for...in`循环在数组上找不到任何属性。

也可以使用 `Array.of` 静态方法来创建包含单个元素的数组。

### 引用数组元素

使用属性访问器  `[]` 来访问。

除了下标，还可以访问数组的其它属性。

### 填充数组

通过给数组元素赋值来填充数组

在创建数组的时候来填充数组

**遍历数组**

`for`

`forEach()` 方法

**数组对象Array的方法**

- `concat()` 连接两个或多个数组并返回一个新的数组。

- `join()` 将数组中的所有元素连接成一个字符串

- `push()` 在数组末尾添加一个或多个元素

- `pop()` 从数组中移出最后一个元素，并返回该元素（移出的元素）

- `shift()` 从数组中移出第一个元素，并返回该元素（移出的元素）

- `unshift()` 在数组开头添加一个或多个元素，并且返回数组的新长度

- `slice()` 从数组中提取一个片段，并作为一个新数组返回

- `at()` 返回数组中指定索引处的元素，如果索引超出范围，则返回 `undefined`,主要用于从数组末尾访问元素的负下标

- `splice()` 方法从数组移除一些元素，并（可选地）替换它们。它返回从数组中删除的元素。

  ```js
  const myArray = ["1", "2", "3", "4", "5"];
  myArray.splice(1, 3, "a", "b", "c", "d");
  // myArray 现在是 ["1", "a", "b", "c", "d", "5"]
  // 本代码从 1 号索引开始（或元素“2”所在的位置），
  // 移除 3 个元素，然后将后续元素插入到那个位置上。
  ```

- `reverse()` 原地颠倒数组元素的顺序：第一个数组元素变为最后一个数组元素，最后一个数组元素变为第一个数组元素。它返回对数组的引用。

- `flat()` 返回一个新数组，所有子数组元素递归地连接到其中，直到指定的深度。

  ```js
  let myArray = [1, 2, [3, 4]];
  myArray = myArray.flat();
  // myArray 现在是 [1, 2, 3, 4]，因为子数组 [3, 4] 已被展平
  ```

- `sort()` 对数组的元素进行适当的排序，并返回对数组的引用。

- `indexOf()` 在数组中搜索 `searchElement` 并返回第一个匹配的索引

- `lastIndexOf()` 工作原理类似于 `indexOf`，但这是从末尾开始，反向搜索

- `forEach()` 对数组中的每个元素执行 `callback` 并返回 `undefined`。

- `map()` 返回由每个数组元素上执行 `callback` 的返回值所组成的新数组。

- `flatMap()` 先执行 `map()`，再执行深度为 1 的 `flat()`。

- `filter()` 返回一个新数组，其中包含 `callback` 返回 `true` 的元素。**过滤器**

- `find()` 返回 `callback` 返回 `true` 的第一个元素。

- `findLast()` 返回 `callback` 返回 `true` 的最后一个元素。

- `findIndex()` 返回 `callback` 返回 `true` 的第一个元素的索引。

- `findLastIndex()` 返回 `callback` 返回 `true` 的最后一个元素的索引。

- `reduce()` 对数组中的每个值执行 `callback(accumulator, currentValue, currentIndex, Array)`，目的是将列表中的元素减少到单个值。`reduce` 函数返回 `callback` 函数返回的最终值。

  ```js
  const a = [10, 20, 30];
  const total = a.reduce(
    (accumulator, currentValue) => accumulator + currentValue,
    0,
  );
  console.log(total); // 60
  ```

- `reduceRight()` 工作原理类似于 `reduce()`，但从最后一个元素开始。 `reduce` 和 `reduceRight` 是迭代数组方法中最不被人熟知的两个函数。它们应该使用在那些需要把数组的元素两两递归处理，并最终计算成一个单一结果的算法。

### 稀疏数组

数组可以包含“空槽”，这与用值 `undefined` 填充的槽不一样。空槽可以通过以下方式之一创建：

```js
// Array 构造函数：
const a = Array(5); // [ <5 empty items> ]

// 数组字面量中的连续逗号：
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// 直接给大于 array.length 的索引设置值以形成空槽：
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// 通过直接设置 .length 拉长一个数组：
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// 删除一个元素：
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]
```

在某些操作中，空槽的行为就像它们被填入了 `undefined` 那样。

```js
const arr = [1, 2, , , 5]; // 创建一个稀疏数组

// 通过索引访问
console.log(arr[2]); // undefined

// For...of
for (const i of arr) {
  console.log(i);
}

// 输出：1 2 undefined undefined 5

// 展开运算
const another = [...arr]; // "another" 为 [ 1, 2, undefined, undefined, 5 ]
```

在其他方法，特别是数组迭代方法时，空槽是被跳过的。

```js
const mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// 属性迭代
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// 输出：'0' '1' '4'
// 在对象中使用展开，使用属性枚举，而不是数组的迭代器
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }
```

### 多维数组

数组是可以嵌套的，这就意味着一个数组可以作为一个元素被包含在另外一个数组里面。

利用 JavaScript 数组的这个特性，可以创建多维数组。

### 使用数组存储其它属性

数组也可以像对象那样使用，以存储相关信息：

```js
const arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"
```

## 10.带键的集合

### Map

`Map`对象就是一个简单的键/值对映射集合，可以按照数据插入时的顺序遍历所有的元素。

### Set

`Set`对象是一组唯一值的集合，可以按照添加顺序来遍历。`Set` 中的值只能出现一次；它在集合 `Set` 中是唯一的。

`Array.from` 数组和Set之间的转换

## 11.使用对象

JavaScript 的设计是一个简单的基于对象的范式。

一个对象就是一系列属性的集合，一个属性包含一个名和一个值。

一个属性的值可以是函数，这种情况下属性也被称为*方法*。

### 对象和属性

一个 javascript 对象有很多属性。

一个对象的属性可以被解释成一个附加到对象上的变量。

对象的属性和普通的 javascript 变量基本没什么区别，仅仅是属性属于某个对象。

属性定义了对象的特征。你可以通过点符号来访问一个对象的属性。

```js
objectName.propertyName;
```

可以在定义一个属性的时候就给它赋值。

对象中未赋值的属性的值为`undefined`（而不是`null`）。

JavaScript 对象的属性也可以通过方括号访问。

JavaScript 中的对象只能使用 String 类型作为键类型。

使用`for…in`语句，枚举一个对象的所有属性

### 枚举一个对象的所有属性

从ES5之后，有三种原生的方法用于列出或枚举对象的属性：

- `for...in`循环，该方法依次访问一个对象及其原型链中所有可枚举的属性。
- `Object.keys(o)`该方法返回对象 `o` 自身包含（不包括原型中）的所有可枚举属性的名称的数组。
- `Object.getOwnPropertyNames(o)`该方法返回对象 `o` 自身包含（不包括原型中）的所有属性 (无论是否可枚举) 的名称的数组。

### 创建新对象

**使用对象初始化器**

可以通过对象初始化器（Object Initializer）创建对象。

使用对象初始化器也被称作通过字面值创建对象。

语法：

```js
var obj = {
  property_1: value_1, // property_# 可以是一个标识符...
  2: value_2, // 或一个数字...
  ["property" + 3]: value_3, //  或一个可计算的 key 名...
  // ...,
  "property n": value_n,
}; // 或一个字符串
```

或者你可以创建一个构造函数并使用该函数和 `new` 操作符初始化对象。

**使用构造函数**

作为另一种方式，你可以通过两步来创建对象：

1. 通过创建一个构造函数来定义对象的类型。首字母大写是非常普遍而且很恰当的惯用法。
2. 通过 `new` 创建对象实例

```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

现在你可以象这样创建一个 `mycar` 对象：

```js
var mycar = new Car("Eagle", "Talon TSi", 1993);
```

**使用 Object.create 方法**

对象也可以用 `Object.create()` 方法创建。

该方法非常有用，因为它允许你为创建的对象选择一个原型对象，而不用定义构造函数。

```js
// Animal properties and method encapsulation
var Animal = {
  type: "Invertebrates", // 属性默认值
  displayType: function () {
    // 用于显示 type 属性的方法
    console.log(this.type);
  },
};

// 创建一种新的动物——animal1
var animal1 = Object.create(Animal);
animal1.displayType(); // Output:Invertebrates

// 创建一种新的动物——Fishes
var fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Output:Fishes
```

### 继承

所有的 JavaScript 对象至少继承于一个对象。

被继承的对象被称作原型，并且继承的属性可通过构造函数的 `prototype` 对象找到。

**对象属性索引**

在 JavaScript 1.0 中，你可以通过名称或序号访问一个属性。

但是在 JavaScript 1.1 及之后版本中，如果你最初使用名称定义了一个属性，则你必须通过名称来访问它；

而如果你最初使用序号来定义一个属性，则你必须通过索引来访问它。

**为对象类型定义属性**

你可以通过 `prototype`属性为之前定义的对象类型增加属性。

```js
Car.prototype.color = null;
car1.color = "black";
```

### 定义方法

一个*方法* 是关联到某个对象的函数，或者简单地说，一个方法是一个值为某个函数的对象属性。定义方法就像定义普通的函数，除了它们必须被赋给对象的某个属性。

```js
objectName.methodname = function_name;

var myObj = {
  myMethod: function(params) {
    // ...do something
  }

  // 或者 这样写也可以

  myOtherMethod(params) {
    // ...do something else
  }
};
```

你可以在对象的上下文中象这样调用方法：

```js
object.methodname(params);
```

### 通过 `this` 引用对象

JavaScript 有一个特殊的关键字 `this`，它可以在方法中使用以指代当前对象。

总的说来， `this` 在一个方法中指调用的对象。

### 定义 getter 与 setter

- 使用**使用对象初始化器**定义
- 也可以之后随时使用 getter 和 setter 添加方法添加到任何对象
  - `Object.defineProperties(object, {})`

### 删除属性

用 `delete`操作符删除一个**不是继承而来**的属性。

### 比较对象

在 JavaScript 中 objects 是一种引用类型。

两个独立声明的对象永远也不会相等，即使他们有相同的属性，只有在比较一个对象和这个对象的引用时，才会返回 true。

三等，比较引用，双等，比较值。

## 12.使用类

在许多其他语言中，*类*（或构造函数）与*对象*（或实例），是两个不同的概念。

在 JavaScript 中，类可以看作是已有的原型继承机制的一种抽象——所有语法都可以转换为原型继承。

类本身也是不过是 JavaScript 里一种普通的值，它们有其自己的原型链。

事实上，大多数 JavaScript 纯函数都可用作构造函数——你可以用 `new` 运算符来调用一个构造函数以创建出一个新的对象。

底层原型系统、继承与原型链。

### 概述

基本概念：

- 类通过 `new`运算符创建对象。
- 每个对象都有一些属性（数据或方法），这些属性是由类添加的。
- 类本身也有一些属性（数据或方法），这些属性通常用于与实例进行交互。

关键特征：

- 构造函数；
- 实例方法和实例字段；
- 静态方法和静态字段。

### 声明一个类

类通常通过*类声明*来创建。

```js
class MyClass {
  // 类体...
}
```

在类体内，有若干特性可用。

```js
class MyClass {
  // 构造函数
  constructor() {
    // 构造函数体
  }
  // 实例字段
  myField = "foo";
  // 实例方法
  myMethod() {
    // myMethod 体
  }
  // 静态字段
  static myStaticField = "bar";
  // 静态方法
  static myStaticMethod() {
    // myStaticMethod 体
  }
  // 静态块
  static {
    // 静态初始化代码
  }
  // 字段、方法、静态字段、静态方法、静态块都可以使用私有形式
  #myPrivateField = "bar";
}
```

**构造一个类**

在声明一个类之后，你可以使用 `new`运算符来创建它的实例。

典型函数构造器可以使用 `new` 来构造，也可以不使用 `new` 来调用。

然而，对于类的调用则必须使用 `new`，否则会导致错误。

**类声明的提升**

与函数声明不同，这意味着你不能在声明之前使用类。

**类表达式**

类似于函数，类声明也有其表达式形式。

```js
const MyClass = class {
  // 类体...
};
```

类表达式也可以有名字。表达式的名字只在类体内可见。

```js
const MyClass = class MyClassLongerName {
  // 类体。这里 MyClass 和 MyClassLongerName 指向同一个类
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
```

### 构造函数

类最重要的工作之一就是作为对象的“工厂”。

实例的创建是通过构造函数来完成的。

每一次调用 `new` 都将创建一个新的实例。

### 实例方法

如果一个类只有构造函数，那么它与一个只创建普通对象的 `createX` 工厂函数并没有太大的区别。然而，类的强大之处在于它们可以作为“模板”，自动将方法分配给实例。

### 私有字段

在面向对象编程中，有一个叫做“封装”的哲学。

这是说你不应该访问对象的底层实现，而是使用抽象方法来与之交互。

私有字段是以 `#`（井号）开头的标识符。井号是这个字段名的必要部分，这也就意味着私有字段永远不会与公共属性发生命名冲突。为了在类中的任何地方引用一个私有字段，你必须在类体中*声明*它（你不能在类体外部创建私有字段）。除此之外，私有字段与普通属性几乎是等价的。

在类外访问私有字段会导致语法错误，且该错误可以在早期被捕获（早期语法错误）。

### getter字段

*getter 字段*允许我们像访问“实际属性”一样操作某些东西。

如果一个字段仅有一个 getter 而没有 setter，它将是只读的。

### 公共字段

公共字段使得实例可以获得属性，且它们常常独立于构造函数的参数。

公共字段几乎等价于将一个属性赋值给 `this`。

### 静态属性

*静态属性*是一组在类本身上定义的特性，而不是在类的实例上定义的特性。这些特性包括：

- 静态方法
- 静态字段
- 静态 getter 与 setter

静态属性与实例属性的区别在于：

- 它们有 `static` 前缀
- 它们不能从实例中访问

有一个特殊结构叫做*静态初始化块*，它是一个在类第一次加载时运行的代码块。

`static{}`

静态初始化块几乎等价于在类声明之后立即执行一些代码。唯一的区别是它们可以访问静态私有属性。

### 扩展与继承

类的一个关键特性（除了私有字段）是*继承*，这意味着一个对象可以“借用”另一个对象的大部分行为，同时覆盖或增强某些部分的逻辑。

所以，在面向对象编程中，我们更愿意创建一个*派生类*。派生类可以访问父类的所有公共属性。

在 JavaScript 中，派生类是通过 `extends`子句声明的，它指示它扩展自哪个类。

### 为什么使用类？

类引入了一种*范式*，或者说是一种组织代码的方式。

类是面向对象编程的基础，而面向对象编程是建立在诸如继承和多态（特别是*子类型多态*）等概念之上的。

而使用类的情况：视情况而定。

## 13.使用Promise

Promise是一个对象，它代表了一个异步操作的最终完成或者失败。

本质上 Promise 是一个函数返回的对象，我们可以在它上面绑定回调函数，这样我们就不需要在一开始把回调函数作为参数传入这个函数了。

### 链式调用

见证奇迹的时刻：`then()` 函数会返回一个和原来不同的**新的 Promise**

```js
const promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);
```

**备注：**如果你想要一个可以操作的示例，你可以使用下面的模板来创建任何返回 Promise 的函数：

```js
function doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // 在完成 Promise 之前的其他操作
      console.log("完成了一些事情");
      // promise 的兑现值
      resolve("https://example.com/");
    }, 200);
  });
}
```

就像这样，你可以创建一个更长的处理链，其中的每个 Promise 都代表了链中的一个异步过程的完成。此外，`then` 的参数是可选的，`catch(failureCallback)` 等同于 `then(null, failureCallback)`——所以如果你的错误处理代码对所有步骤都是一样的，你可以把它附加到链的末尾：

```js
doSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`得到最终结果：${finalResult}`);
  })
  .catch(failureCallback);
```

你或许会看到这种形式的箭头函数：

```js
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`得到最终结果：${finalResult}`);
  })
  .catch(failureCallback);
```

**备注：**箭头函数表达式可以有隐式返回值；所以，`() => x` 是 `() => { return x; }` 的简写。

一个经验法则是，每当你的操作遇到一个 Promise，就返回它，并把它的处理推迟到下一个 `then` 处理器中。

使用 `async`/`await`可以帮助你编写更直观、更类似同步代码的代码。

**备注：**async/await 的并发语义与普通 Promise 链相同。异步函数中的 `await` 不会停止整个程序，只会停止依赖其值的部分，因此在 `await` 挂起时，其他异步任务仍可运行。

### 错误处理

通常，一遇到异常抛出，浏览器就会顺着 Promise 链寻找下一个 `onRejected` 失败回调函数或者由 `.catch()` 指定的回调函数。

**嵌套**

嵌套是一种可以限制 `catch` 语句的作用域的控制结构写法。明确来说，嵌套的 `catch` 只会捕获其作用域及以下的错误，而不会捕获链中更高层的错误。如果使用正确，可以实现细粒度的错误恢复。

**备注：**如果没有复杂的错误处理，则很可能不需要嵌套的 `then` 处理器。相反，可以使用扁平链，将错误处理逻辑放在最后。

**Catch 的后续链式操作**

有可能会在一个回调失败*之后*继续使用链式操作

**Promise 拒绝事件**

当一个 Promise 拒绝事件未被任何处理器处理时，它会冒泡到调用栈的顶部，主机需要将其暴露出来。在 Web 上，当 Promise 被拒绝时，会有下文所述的两个事件之一被派发到全局作用域（通常而言，就是`window`；如果是在 web worker 中使用的话，就是 `Worker` 或者其他基于 worker 的接口）。

`rejectionhandled`

当 Promise 被拒绝、并且在 `reject` 函数处理该拒绝事件之后会派发此事件。

`unhandledrejection`

当 Promise 被拒绝，但没有提供 `reject` 函数来处理该拒绝事件时，会派发此事件。

上述两种事件（类型为 `PromiseRejectionEvent`）都有两个属性，一个是 `promise`属性，该属性指向被拒绝的 Promise，另一个是 `reason`属性，该属性用来说明 Promise 被拒绝的原因。

因此，我们可以通过以上事件为 Promise 失败时提供补偿处理，也有利于调试 Promise 相关的问题。在每一个上下文中，该处理都是全局的，因此不管源码如何，所有的错误都会在同一个处理函数中被捕捉并处理。

在 Node.js 中，对拒绝事件的处理稍有不同。你可以通过为 Node.js 的 `unhandledRejection` 事件添加处理器（注意名称的大小写不同）来捕获未处理的拒绝

### 组合

有四个组合工具可用来并发异步操作：

- `Promise.all()`
- `Promise.allSettled()`
- `Promise.any()` 
- `Promise.race()`

### 在旧式回调 API 中创建 Promise

可以通过 Promise 的构造函数从零开始创建 `Promise`。

这种方式（通过构造函数的方式）应当只在封装旧 API 的时候用到。

理想状态下，所有的异步函数应该会返回 Promise。但有一些 API 仍然使用旧方式来传入成功（或者失败）的回调。最典型的例子就是 `setTimeout()`函数：

```js
setTimeout(() => saySomething("10 秒钟过去了"), 10 * 1000);
```

幸运地是，我们可以将 `setTimeout()` 封装入 Promise 内。最好的做法是，将这些有问题的函数封装起来，留在底层，并且永远不要再直接调用它们：

```js
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 秒钟"))
  .catch(failureCallback);
```

通常，Promise 的构造函数接收一个执行函数（executor），我们可以在这个执行函数里手动地解决（resolve）或拒绝（reject）一个 Promise。既然 `setTimeout()` 并不会真的执行失败，那么我们可以在这种情况下忽略拒绝的情况。

### 时序

关于注册的回调函数何时被调用。

**保证**

在基于回调的 API 中，回调函数何时以及如何被调用取决于 API 的实现者。

另一方面，Promise 是一种**控制反转**的形式——API 的实现者不控制回调何时被调用。

维护回调队列并决定何时调用回调的工作被委托给了 Promise 的实现者，这样一来，API 的使用者和开发者都会自动获得强大的语义保证，包括：

- 被添加到 `then()`的回调永远不会在 JavaScript 事件循环的当前运行完成之前被调用。
- 即使异步操作已经完成（成功或失败），在这之后通过 `then()`添加的回调函数也会被调用。
- 通过多次调用`then()`可以添加多个回调函数，它们会按照插入顺序进行执行。

以防万一的提醒：传入`then()`的函数永远不会被同步调用，即使 Promise 已经被解决了（resolved）：

```js
Promise.resolve().then(() => console.log(2));
console.log(1); // 1, 2
```

传入 `then()` 的函数不会立即运行，而是被放入微任务队列中，这意味着它会在稍后运行（仅在创建该函数的函数退出后，且 JavaScript 执行堆栈为空时。

总而言之，不会等待太久。

**任务队列 vs 微任务**

Promise 回调被处理为微任务，而 `setTimeout()`回调被处理为任务队列。

**当Promise与任务冲突时**

你可能遇到如下情况：你的一些 Promise 和任务（例如事件或回调）会以不可预测的顺序启动。此时，你或许可以通过使用微任务检查状态或平衡 Promise，并以此有条件地创建 Promise。

## 14.JavaScript类型化数组

JavaScript 类型化数组是一种类似数组的对象，并提供了一种用于在内存缓冲中访问原始二进制数据的机制。

引入类型化数组并非是为了取代 JavaScript 中数组的任何一种功能。相反，它为开发者提供了一个**操作二进制数据**的接口。

这在操作与平台相关的特性时会很有用，例如：音频视频编辑和访问**WebSocket**原始数据等。

JavaScript 类型化数组中的每一个元素都是以某种格式表示的原始二进制值，JavaScript 支持从 8 位整数到 64 位浮点数的多种二进制格式。

类型化数组拥有许多与数组相同的方法，语义也相似。

但是，类型化数组并不是普通数组，因为在类型化数组上调用 `Array.isArray()`会返回 `false`。

此外，并不是所有可用于普通数组的方法都能被类型化数组所支持（如 push 和 pop）。

为了最大程度的灵活性和效率，JavaScript 将类型化数组的实现拆分为*缓冲*和*视图*两部分。

缓冲是一种表示了数据块的对象，它没有格式可言，也没有提供访问其内容的机制。

为了访问缓冲中的内存，你需要使用视图。

视图提供了*上下文*——即数据类型、起始偏移量和元素数量。

### 缓冲

有两种类型的缓冲：`ArrayBuffer`和 `SharedArrayBuffer`。

它们都是内存块的低级表示。

它们名字中都含有“array”，但是它们与数组并没有太多关系——你不能直接读写它们。

相反，缓冲是通用的对象，它们只包含原始数据。

为了访问缓冲所表示的内存，你需要使用视图。

缓冲支持以下操作：

- *分配*：创建一个新的缓冲时，会分配一个新的内存块，并且初始化为 `0`。
- *复制*：使用 `slice()`方法，你可以高效地复制缓冲中的一部分数据，而不需要创建视图来手动复制每一个字节。
- *转移*：使用 `transfer()`和 `transferToFixedLength()` 方法，可以将内存块的所有权转移给一个新的缓冲对象。若你想要在不同的执行上下文间转移数据，又不想复制，这些方法就很有用。转移后，原始缓冲将不再可用。`SharedArrayBuffer` 不能被转移（因为缓冲已经被所有执行上下文共享）。
- *调整大小*：使用 `resize()`方法，可以调整内存块的大小（只要不超过预设的 `maxByteLength` 限制）。`SharedArrayBuffer` 只能增长，不能缩小。

`ArrayBuffer` 与 `SharedArrayBuffer` 之间的区别是，前者在同一时刻只能所属于单个执行上下文。如果你将 `ArrayBuffer` 传递给另一个执行上下文，它会被*转移*，原始的 `ArrayBuffer` 将不再可用。这确保了同一时刻只有一个执行上下文可以访问内存。`SharedArrayBuffer` 在传递给另一个执行上下文时不会被转移，因此可以被多个执行上下文同时访问。当多个线程同时访问同一内存块时，可能会出现竞争条件，这时候 `Atomics` 方法就很有用了。

### 视图

目前主要有两种视图：类型化数组视图和 `DataView`。

类型化数组提供了**实用方法**，可以方便地转换二进制数据。

`DataView` 更底层，可以精确控制数据的访问方式。使用这两种视图读写数据的方式是非常不同的。

两种视图都会使 `ArrayBuffer.isView()`返回 `true`。它们都有以下属性：

- `buffer`

  视图所引用的底层缓冲。

- `byteOffset`

  视图相对于缓冲起始位置的偏移量（以字节为单位）。

- `byteLength`

  视图的长度（以字节为单位）。

两者的构造函数都接受上述三个分离的参数。类型化数组构造函数还接受 `length` 作为元素数量，而不是字节长度。

**类型化数组视图**

类型化数组视图有自描述的名称，并且提供了所有常见数值类型的视图，如 `Int8`、`Uint32` 和 `Float64` 等等。

**DataView**

`DataView`是一种底层接口，它提供可以操作缓冲中任意数据的 getter/setter API。

`DataView` 不需要对齐，多字节读写可以从任意指定的偏移量开始。

**使用类型化数组的WebAPI**

下面是一些使用类型化数组的 API 示例，但，并不完整。

- `FileReader.prototype.readAsArrayBuffer()`

  `FileReader.prototype.readAsArrayBuffer()` 读取对应的 `Blob`或 `File`的内容

- `XMLHttpRequest.prototype.send()`

  `XMLHttpRequest` 实例的 `send()` 方法现在支持使用类型化数组和 `ArrayBuffer`对象作为参数。

- `ImageData.data`

  是一个 `Uint8ClampedArray` 对象，用来描述包含按照 RGBA 序列的颜色数据的一维数组，其值的范围在 `0` 到 `255` 之间。

### 示例

**使用视图和缓冲**

首先，我们需要创建一个 16 字节固定长度的缓冲：

```js
const buffer = new ArrayBuffer(16);
```

现在我们有了一段初始化为 0 的内存，目前还做不了什么太多操作。让我们确认一下数据的字节长度：

```js
if (buffer.byteLength === 16) {
  console.log("是 16 字节。");
} else {
  console.log("大小有问题！");
}
```

在实际开始操作这个缓冲之前，还需要一个视图。现在，我们就创建一个视图，该视图将把缓冲内的数据视为一个 32 位有符号整数数组：

```js
const int32View = new Int32Array(buffer);
```

现在我们可以像普通数组一样访问该数组中的元素：

```js
for (let i = 0; i < int32View.length; i++) {
  int32View[i] = i * 2;
}
```

该代码会将数组以 `0`、`2`、`4` 和 `6` 填充（一共 4 个 4 字节元素，所以总长度为 16 字节）。

**相同数据上的多个视图**

更有意思的是，你可以在同一数据上创建多个视图。例如：基于上文的代码，我们可以像这样继续操作：

```js
const int16View = new Int16Array(buffer);

for (let i = 0; i < int16View.length; i++) {
  console.log(`索引 ${i}：${int16View[i]}`);
}
```

这里我们创建了一个 16 位整数视图，该视图共享上文的 32 位整数视图的缓冲，然后以 16 位整数打印出缓冲里的数据，这次我们会得到 `0`、`0`、`2`、`0`、`4`、`0`、`6`、`0` 这样的输出（假设是小端序编码）。

```
Int16Array  |   0  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |      0      |      2      |      4      |      6      |
ArrayBuffer | 00 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |
```

进一步地：

```js
int16View[0] = 32;
console.log(`32 位数组的索引 0 处数据是：${int32View[0]}`);
```

这次的输出是 `"32 位数组的索引 0 处数据是：32"`。也就是，这 2 个数组都是同一数据的以不同格式展示出来的视图。

```
Int16Array  |  32  |  0   |   2  |  0   |   4  |  0   |   6  |  0   |
Int32Array  |     32      |      2      |      4      |      6      |
ArrayBuffer | 20 00 00 00 | 02 00 00 00 | 04 00 00 00 | 06 00 00 00 |
```

你可以对任意视图类型进行这样的操作，尽管如果你设置一个整数，然后以浮点数的形式读取它，你可能会得到一个奇怪的结果，因为位的解释方式不同。

```js
const float32View = new Float32Array(buffer);
console.log(float32View[0]); // 4.484155085839415e-44
```

**从缓冲读取文本**

缓冲并不总是表示数字。例如，读取文件可以给你一个文本数据缓冲。你可以使用类型化数组从缓冲中读取这些数据。

下面的代码使用 `TextDecoder`web API 读取 UTF-8 文本：

```js
const buffer = new ArrayBuffer(8);
const uint8 = new Uint8Array(buffer);
// 我们手动写入数据，假装它已经在缓冲区中了
uint8.set([228, 189, 160, 229, 165, 189]);
const text = new TextDecoder().decode(uint8);
console.log(text); // "你好"
```

下面的代码使用 `String.fromCharCode()`方法读取 UTF-16 文本：

```js
const buffer = new ArrayBuffer(8);
const uint16 = new Uint16Array(buffer);
// 我们手动写入数据，假装它已经在缓冲区中了
uint16.set([0x4f60, 0x597d]);
const text = String.fromCharCode(...uint16);
console.log(text); // "你好"
```

**使用复杂的数据结构**

通过将缓冲与不同类型视图组合，以及修改内存访问的偏移量，你可以操作包含更多更复杂数据结构的数据。例如，你可以操作诸如 **WebGL** 或数据文件这些复杂的数据结构。

请看如下的 C 语言结构体：

```c
struct someStruct {
  unsigned long id;
  char username[16];
  float amountDue;
};
```

你可以采用如下代码访问一个包含此类结构体的缓冲：

```js
const buffer = new ArrayBuffer(24);

// …将数据读入缓冲…

const idView = new Uint32Array(buffer, 0, 1);
const usernameView = new Uint8Array(buffer, 4, 16);
const amountDueView = new Float32Array(buffer, 20, 1);
```

这样一来，你就得到了一个类似的数据结构，例如，`amountDueView[0]` 对应了 C 的 `amountDue` 字段。

> **备注**：C 语言结构体的**数据对齐**与平台相关。因此需要防范和考虑不同平台字节填充对齐的差异。

**转换为普通数组**

在处理完一个类型化数组后，有时需要把它转为普通数组，以便可以从 `Array` 原型中受益。可以通过使用 `Array.from()`实现：

```js
const typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = Array.from(typedArray);
```

也可以使用**展开语法**。

```js
const typedArray = new Uint8Array([1, 2, 3, 4]);
const normalArray = [...typedArray];
```

## 15.迭代器和生成器

迭代器和生成器将迭代的概念直接带入核心语言，并提供了一种机制来自定义 `for...of` 循环的行为。

### 迭代器

在 JavaScript 中，**迭代器**是一个对象，它定义一个序列，并在终止时可能附带一个返回值。

更具体地说，迭代器是通过使用 `next()` 方法实现了**迭代器协议**的任何一个对象，该方法返回具有两个属性的对象：

- `value`

- `done`

  如果已经迭代到序列中的最后一个值，则它为 `true`。

  如果 `value` 和 `done` 一起出现，则它就是迭代器的返回值。

一旦创建，迭代器对象可以通过重复调用 `next()` 显式地迭代。

迭代一个迭代器被称为消耗了这个迭代器，因为它通常只能执行一次：在产生终值后，对 `next()` 的额外调用应该继续返回 `{done：true}`。

虽然很容易想象所有迭代器都可以表示为数组，但事实并非如此。数组必须完整分配，而迭代器则是按需分配。因此，迭代器可以表示无限大小的序列，例如 0 和 `Infinity`之间的整数范围。

### 生成器函数

虽然自定义迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此创建时要格外谨慎。

**生成器函数**（Generator 函数）提供了一个强大的替代选择：它允许你定义一个非连续执行的函数作为迭代算法。

生成器函数使用 `function*`语法编写。

最初调用时，生成器函数不执行任何代码，而是返回一种称为**生成器**的特殊迭代器。通过调用 `next()` 方法消耗该生成器时，生成器函数将执行，直至遇到 `yield` 关键字。

可以根据需要多次调用该函数，并且每次都返回一个新的生成器，但每个生成器只能迭代一次。

### 可迭代对象

若一个对象拥有迭代行为，比如在 `for...of` 中会循环一些值，那么那个对象便是一个可迭代对象。一些内置类型，如 `Array`或 `Map`拥有默认的迭代行为，而其他类型（比如 `Object`）则没有。

为了实现**可迭代**，对象必须实现 `[Symbol.iterator]()` 方法，这意味着这个对象（或其[原型链](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)中的任意一个对象）必须具有一个键值为 `Symbol.iterator`的属性。

程序员应知道一个可迭代对象可以多次迭代，还是只能迭代一次。

只能迭代一次的可迭代对象（例如生成器）通常从它们的 `[Symbol.iterator]()` 方法中返回 `this`，而那些可以多次迭代的方法必须在每次调用 `[Symbol.iterator]()` 时返回一个新的迭代器。

**自定义的可迭代对象**

```js
var myIterable = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
  },
};
```

自定义的可迭代对象可用 `for...of` 循环或者展开语法进行迭代。

```js
for (let value of myIterable) {
  console.log(value);
}
// 1
// 2
// 3

[...myIterable]; // [1, 2, 3]
```

**内置可迭代对象**

`String`、`Array`、`TypedArray`、`Map` 和 `Set` 都是内置可迭代对象，因为它们的原型对象都拥有一个 `Symbol.iterator` 方法。

**用于可迭代对象的语法**

一些语句和表达式专用于可迭代对象，例如 `for...of`循环、展开语法、`yield*`和解构语法。

```js
for (let value of ["a", "b", "c"]) {
  console.log(value);
}
// "a"
// "b"
// "c"

[..."abc"]; // ["a", "b", "c"]

function* gen() {
  yield* ["a", "b", "c"];
}

gen().next(); // { value: "a", done: false }

[a, b, c] = new Set(["a", "b", "c"]);
a; // "a"
```

### 高级生成器

生成器会*按需*计算它们 `yield` 的值，这使得它们能够高效地表示一个计算成本很高的序列，甚至是前文所示的一个无限序列。

`next()` 方法也接受一个参数用于修改生成器内部状态。

传递给 `next()` 的参数值会被 `yield` 接收。

**备注：**传给*第一个* `next()` 的值会被忽略。

下面的是斐波那契数列生成器，它使用了 `next(x)` 来重启序列：

```js
function* fibonacci() {
  let current = 0;
  let next = 1;
  while (true) {
    const reset = yield current;
    [current, next] = [next, next + current];
    if (reset) {
      current = 0;
      next = 1;
    }
  }
}

const sequence = fibonacci();
console.log(sequence.next().value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5
console.log(sequence.next().value); // 8
console.log(sequence.next(true).value); // 0
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
```

你可以通过调用其 `throw()`方法强制生成器抛出异常，并传递应该抛出的异常值。这个异常将从当前挂起的生成器的上下文中抛出，就好像当前挂起的 `yield` 是一个 `throw value` 语句。

如果该异常没有在生成器内部被捕获，则它将通过 `throw()` 的调用向上传播，对 `next()` 的后续调用将导致 `done` 属性为 `true`。

生成器的 `return()`方法可返回给定的值并终结这个生成器。

## 16.元编程

`Proxy`和 `Reflect`对象允许你拦截并自定义基本语言操作（例如属性查找、赋值、枚举和函数调用等）。

借助这两个对象，你可以在 JavaScript 进行元级别的编程。

### 代理

`Proxy`对象可以拦截某些操作并实现自定义行为。

### 反射

`Reflect`是一个内置对象，它为可拦截的 JavaScript 操作提供了方法。

## JavaScript模块

JavaScript 程序本来很小——在早期，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境（例如 Node.js）。



