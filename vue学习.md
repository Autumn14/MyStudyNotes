# vue学习

## 1.声明式渲染

SFC Vue 单文件组件 (Single-File Component)

响应式 VUE使用 `reactive()` API来声明响应式状态

`reactive()` 只适用于对象 (包括数组和内置类型，如 `Map` 和 `Set`)

另一个 API `ref()` 则可以接受任何值类型

`ref` 会返回一个包裹对象，并在 `.value` 属性下暴露内部值

双花括号语法: 在双花括号中的内容并不只限于标识符或路径——我们可以使用任何有效的 JavaScript 表达式

## 2.Attribute 绑定

mustache 语法 (即双大括号) 只能用于文本插值

给 attribute 绑定一个动态值，需要使用 `v-bind` 指令

: 简写

## 3.事件监听

使用 `v-on` 指令监听 DOM 事件

@ 简写

## 4.表单绑定

同时使用 `v-bind` 和 `v-on` 来在表单的输入元素上创建双向绑定

简化双向绑定 `v-model` 指令 上述操作的语法糖

## 5.条件渲染

 `v-if` 指令 

也可以使用 `v-else` 和 `v-else-if` 来表示其他的条件分支

true 渲染  false 移除

## 6.列表渲染

 `v-for` 指令

`v-for` 指令的值需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据的数组，而 `item` 是迭代项的**别名**

items.value.push

items.value.filter

## 7.计算属性

新的API：`computed()`

## 8.生命周期和模板引用

Vue 为我们处理了所有的 DOM 更新，这要归功于响应性和声明式渲染。然而，有时我们也会不可避免地需要手动操作 DOM

这时我们需要使用**模板引用**——也就是指向模板中一个 DOM 元素的 ref

需要通过这个特殊的 `ref` attribute来实现模板引用 `<template>`中

要访问该引用，我们需要声明一个同名的 ref `<script>`中

注意这个 ref 使用 `null` 值来初始化。（这是因为当 `<script setup>` 执行时，DOM 元素还不存在。模板引用 ref 只能在组件**挂载**后访问）

要在挂载之后执行代码，我们可以使用 `onMounted()` 函数

这被称为**生命周期钩子**——它允许我们注册一个在组件的特定生命周期调用的回调函数

还有一些其他的钩子如 `onUpdated` 和 `onUnmounted`

![](C:\Users\Rain7\Desktop\笔记md\图片\vuelifecycle.png)

##  9.侦听器

`watch()` 可以直接侦听一个 ref

## 10.组件

真正的 Vue 应用往往是由嵌套组件创建的

父组件可以在模板中渲染另一个组件作为子组件。要使用子组件，我们需要先导入它

然后我们就可以在模板中使用组件，用**标签**

## 11.Props

子组件可以通过 **props** 从父组件接受动态数据。

首先，需要声明它所接受的 props

父组件可以像声明 HTML attributes 一样传递 props。

若要传递动态值，也可以使用 `v-bind` 语法

**子组件接受父组件的动态数据**

## 12.Emits

除了接收 props，子组件还可以向父组件触发事件

`emit()` 的第一个参数是事件的名称。其他所有参数都将传递给事件监听器

父组件可以使用 `v-on` 监听子组件触发的事件

**子组件向父组件触发事件**

## 13.插槽

父组件还可以通过**插槽** (slots) 将模板片段传递给子组件

在子组件中，可以使用 `<slot>` 元素作为插槽出口 (slot outlet) 渲染父组件中的插槽内容 (slot content)

`<slot>` 插口中的内容将被当作“默认”内容：它会在父组件没有传递任何插槽内容时显示

**子组件定义插槽，父组件给子组件传值**

